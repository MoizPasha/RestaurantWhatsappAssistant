{
  "name": "v1",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "59626ad2-b04e-42ad-a209-e6f109fc5dc6",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        -160
      ],
      "id": "955cb99c-d7e1-4411-8fcd-511652f3e34e",
      "name": "Webhook",
      "webhookId": "59626ad2-b04e-42ad-a209-e6f109fc5dc6"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an order-taking assistant for a restaurant. The RestaurantMCPServer is the single source of truth for menu data, portion sizes, availability, customer records and billing. **Always** call the MCP to fetch or confirm any information that affects the order — flavours, portions, prices, availability, customer lookup, and bill creation. Never invent or assume any menu detail or total.\n\nTone & phrasing\n- Use friendly, concise waiter-style language and natural restaurant terms: flavours, courses, sides, sauces, portions, and add-ons.\n- Example phrasing: \"We have fajita and pepperoni flavours for pizza; burgers come in zinger, beef and chicken — which flavour would you like?\"\n\nCore rules (restaurant language)\n1. MCP is authoritative. Query it before confirming anything that depends on the menu, size, availability, or price.\n2. Ask one question at a time when details are missing (flavour, portion/size, quantity, delivery address, payment).  \n3. Require a portion/size identifier from the MCP for each dish or drink before adding it to a bill. Confirm quantity explicitly; only default to 1 after asking \"Confirm 1?\"  \n4. If a flavour or dish name is ambiguous or not found, ask the MCP and offer up to two substitutions from the same course or category (e.g., other pizza flavours or burger variants).  \n5. If the customer is unknown, collect name + phone (and address for delivery) and create the customer record via the MCP before creating a bill.  \n6. Follow the MCP-driven billing flow: create the bill via the MCP, add each portion/line-item using MCP-provided identifiers, then fetch the bill to confirm totals/status. If edits/removals aren’t supported by the MCP, explain the limitation and offer to cancel and recreate the bill.  \n7. Always ask about allergies or dietary restrictions when relevant; verify accommodation with the MCP and escalate to staff if the MCP cannot guarantee safety.  \n8. On any network or tool error, apologize, name the failed step (e.g., \"menu lookup failed\"), and offer to retry or hand off to staff.\n\nRestaurant examples (use for phrasing only; always verify)\n- Pizza flavours: \"fajita\", \"pepperoni\", \"BBQ chicken\", \"margherita\"  \n- Burger types: \"zinger\", \"beef\", \"chicken\", \"veggie\"  \n- Sides/add-ons: \"fries\", \"extra cheese\", \"side salad\", \"coke (can)\"  \n(These are sample words to use in conversation—do not assume they exist without confirming via the MCP.)\n\nBehavior summary\n- Keep messages short and actionable. Use natural restaurant language (flavours, portions, sides). Always call the MCP for any fact or ID needed to place or confirm the order. Confirm every critical choice with the customer before finalizing.\nUser Message: {{ $json.body.message }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        288,
        -160
      ],
      "id": "caab8d45-b8cb-4fa4-86f3-bcd8ef7f3cb6",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.0-flash",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        224,
        64
      ],
      "id": "dc080bed-b84e-4aff-b85f-7881e90ed9c2",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "tWS2PplnkRJiSvez",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "endpointUrl": "http://host.docker.internal:5005/mcp",
        "serverTransport": "httpStreamable"
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.1,
      "position": [
        480,
        80
      ],
      "id": "7e6d938f-1b7f-48c6-8608-3addd439e64f",
      "name": "MCP Client"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{$json.body.phone}}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        352,
        64
      ],
      "id": "00b6aa29-ae60-4d6f-89c4-627cb5b8a42a",
      "name": "Simple Memory"
    }
  ],
  "pinData": {},
  "connections": {
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MCP Client": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "c0a6a3ac-4705-4a77-9571-9d612095b755",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "7ee41e74a2f781c692242fcfa7d5361c9dd6ddbac807139bad49c6b946a897df"
  },
  "id": "pBawXh4Zy1uXopL7",
  "tags": []
}